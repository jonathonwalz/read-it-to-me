{"version":3,"file":"read-it-to-me.esm.js","sources":["../../src/js/read-it-to-me.js","../../src/js/synthesis.js"],"sourcesContent":["import '../scss/read-it-to-me.scss';\n\nimport {initSynthesis} from './synthesis';\n\nlet synth;\nconst ritmDisabledClassName = 'ritm-disabled';\nconst groupClassName = 'read-it-to-me-content-group';\nconst focusClassName = 'focusin';\nlet contentQueue = [];\nlet controlBubble;\nlet controlBar;\nlet ritmEnabled = true;\nlet eventsBin = {\n  play: null,\n  pause: null,\n  cancel: null,\n  toggle: null\n};\n\nlet setup = () => {\n  addReadItToMeElements();\n  attachEvents();\n\n  // Toggle RITM off if set as disabled in sessionStorage\n  if (sessionStorage.getItem('readItToMeDisabled')) {\n    controlBar.querySelector('input.switch-input').checked = false;\n    toggleReadItToMe();\n  }\n};\n\nlet makeElemTabable = (elem) => {\n  if (!elem.hasAttribute('tabindex')) {\n    elem.setAttribute('tabindex', '0');\n  }\n  else {\n    if (!elem.classList.contains('ritm-do-not-strip-tabindex')) {\n      elem.classList.add('ritm-do-not-strip-tabindex');\n    }\n  }\n};\n\nlet addReadItToMeElements = () => {\n  let groupSelectorElements = document.querySelectorAll(`.${groupClassName}`);\n  // Inner wrap each readable group in a new div.read-this-to-me\n  let wrapSource = document.createElement('div');\n  wrapSource.classList.add('read-this-to-me');\n  groupSelectorElements.forEach((elem) => {\n    let wrapper = wrapSource.cloneNode(false);\n    elem.appendChild(wrapper);\n    while (elem.firstChild !== wrapper) {\n      wrapper.appendChild(elem.firstChild);\n    }\n  });\n\n  // build the control bubble\n  controlBubble = document.createElement('div');\n  controlBubble.classList.add('read-it-to-me-control-bubble');\n  controlBubble.innerHTML = '<p class=\"read-it-to-me-label\"></p><button type=\"button\" class=\"play-pause-resume\"></button><button type=\"button\" class=\"cancel-audio\"><span class=\"visually-hidden\">Cancel audio</a></button>';\n\n  // build the control bar\n  controlBar = document.createElement('div');\n  controlBar.classList.add('read-it-to-me-control-bar');\n  controlBar.setAttribute('tabindex', '0');\n  controlBar.setAttribute('aria-describedby', 'ritm-sr-message');\n  controlBar.innerHTML = `<div class=\"toggle-wrapper\">\n                            <p class=\"visually-hidden\" id=\"ritm-sr-message\">Screen-reader users: there is a rudimentary \"on-demand\" read-aloud feature in use on this page called \"Read-it-to-Me\".  This new feature, which isn't meant as a screen-reader alternative, adds more tabable areas in the document which are great for keyboard users not using screen-readers, but are likely to be annoying for you. You can toggle off/on \"Read-it-to-Me\" using this checkbox.</p>\n                            <p class=\"read-it-to-me-label\">Toggle Read-it-to-Me</p>\n                            <label class=\"switch\" aria-label=\"Toggle Read-it-to-Me.\" aria-describedby=\"ritm-sr-message\">\n                              <input type=\"checkbox\" class=\"switch-input\" checked>\n                              <span class=\"switch-outline\"></span>\n                              <span class=\"switch-label\" data-on=\"On\" data-off=\"Off\"></span>\n                              <span class=\"switch-handle\"></span>\n                            </label>\n                          </div>\n                          <div class=\"cancel-audio-wrapper\">\n                            <button type=\"button\" class=\"btn btn-default btn-lg\">Cancel audio</button>\n                          </div>`;\n\n  // append the control bar to body where it's least likely to be effected by layout styling and the control bubble so we can attach events to it.\n  let docBody = document.body;\n  docBody.insertBefore(controlBar, docBody.firstChild);\n  docBody.appendChild(controlBubble);\n};\n\n/* Why a try...catch?  To deal with the interesting behavior that comes out of using appendChild in a blur or focusout listener.\n   Ex: focusout listener runs appendChild which fires a blur event, your focusout listener runs again, attempting\n   to run appendChild again.  At the second run of appendChild your element will still have it's parentNode defined,\n   but your element isn't among it's children anymore! And an exception is thrown:\n   Uncaught DOMException: Failed to execute 'appendChild' on 'Node': The node to be removed is no longer a child of this node. Perhaps it was moved in a 'blur' event handler?\n*/\nlet attachControlBubbleToGroup = (elem) => {\n  if (controlBubble.parentNode !== elem) {\n    try {\n      elem.insertBefore(controlBubble, elem.firstChild);\n    }\n    catch (e) {}\n  }\n};\n\nlet moveControlBubbleToBody = () => {\n  try {\n    document.body.appendChild(controlBubble);\n  }\n  catch (e) {}\n};\n\nlet clearStrayFocus = () => {\n  let strayFocus = document.querySelector(`.${focusClassName}`);\n  if (strayFocus) {\n    strayFocus.classList.remove(focusClassName);\n  }\n};\n\nlet groupSelectorEnter = (e) => {\n  if (!ritmEnabled) {return false;}\n\n  // clean up stray focusin class if there is one\n  clearStrayFocus();\n\n  let targ = e.target;\n  if (targ && targ.matches(`.${groupClassName}`) && !targ.querySelector('.read-it-to-me-control-bubble')) {\n    attachControlBubbleToGroup(targ);\n  }\n};\n\nlet groupSelectorLeave = (e) => {\n  if (!ritmEnabled) {return false;}\n\n  let group = e.relatedTarget ? e.relatedTarget.closest(`.${groupClassName}`) : null;\n\n  if (group) {\n    attachControlBubbleToGroup(group);\n  }\n  else {\n    moveControlBubbleToBody();\n  }\n};\n\nlet groupFocusInListener = (e) => {\n  if (!ritmEnabled) {return false;}\n\n  // don't want this bubbling up from nested groups\n  e.stopPropagation();\n\n  let targ = e.target;\n  let relTarg = e.relatedTarget;\n  let relTargIsInTarg;\n\n  if (targ) {\n    // see if target is a RITM group wrapper (which is what we need)\n    if (targ.matches(`.${groupClassName}`)) {\n      // set our flag here to true if relatedTarget is our control bubble button.\n      relTargIsInTarg = relTarg && targ.firstChild.querySelector('button') === relTarg ? true : false;\n\n      // give it a class to apply some focus visuals (if it doesn't already have one)\n      if (!targ.classList.contains(focusClassName)) {\n        targ.classList.add(focusClassName);\n      }\n      // and then slap the control bubble in there if it isn't there already\n      if (!targ.querySelector('.read-it-to-me-control-bubble')) {\n        attachControlBubbleToGroup(targ);\n      }\n\n      /* if relTargIsInTarg is true than it means the user is in reverse (shift-tabbing) and so\n       we DO NOT want to move focus (back to) the control bubble button (infinite behavior loop traps are bad mkay). */\n      if (!relTargIsInTarg) {\n        // save y scroll and then restore it after focus so users don't experience a disorienting page jump\n        let preFocusPositionY = window.scrollY;\n        targ.firstChild.querySelector('button').focus();\n        window.scroll(0, preFocusPositionY);\n      }\n    }\n  }\n};\n\nlet groupFocusOutListener = (e) => {\n  if (!ritmEnabled) {return false;}\n\n  // don't want this bubbling up from nested groups\n  e.stopPropagation();\n\n  let targ = e.target;\n  let relTarg = e.relatedTarget;\n  let parentGroup;\n\n  if (targ && relTarg) {\n\n    // Bail if focus is moving from wrapper to control bubble, or vice versa\n    if (targ.matches(`.${groupClassName}`) && relTarg.matches('.read-it-to-me-control-bubble button') && targ.contains(relTarg)) {\n      return false;\n    }\n    // Bail if focus is moving from control bubble to it's parent group\n    if (targ.matches('.read-it-to-me-control-bubble button') && relTarg.matches(`.${groupClassName}`) && relTarg.contains(targ)) {\n      return false;\n    }\n    // Bail if focus is moving from one control bubble button to another\n    if (targ.matches('.read-it-to-me-control-bubble button') && relTarg.matches('.read-it-to-me-control-bubble button')) {\n      return false;\n    }\n\n    // get the group wrapper\n    if (targ.matches(`.${groupClassName}`)) {\n      parentGroup = targ;\n    }\n    else {\n      parentGroup = targ.closest(`.${groupClassName}`);\n    }\n\n    // remove focus class from group wrapper and move the control bubble out of sight\n    parentGroup.classList.remove(focusClassName);\n\n    moveControlBubbleToBody();\n  }\n};\n\nlet toggleReadItToMe = (e) => {\n  let toggleSwitch = e ? e.target : controlBar.querySelector('input.switch-input');\n  let groupSelectorElements = document.querySelectorAll(`.${groupClassName}`);\n  if (toggleSwitch.checked) {\n    ritmEnabled = true;\n    sessionStorage.removeItem('readItToMeDisabled');\n    groupSelectorElements.forEach((elem) => {\n      elem.classList.remove(ritmDisabledClassName);\n      makeElemTabable(elem);\n    });\n  }\n  else {\n    ritmEnabled = false;\n    clearStrayFocus();\n    synth.cancel();\n    sessionStorage.setItem('readItToMeDisabled', '1');\n    groupSelectorElements.forEach((elem) => {\n      elem.classList.add(ritmDisabledClassName);\n      if (!elem.classList.contains('ritm-do-not-strip-tabindex')) {\n        elem.removeAttribute('tabindex');\n      }\n    });\n  }\n\n  // optional track toggle event\n  if (e && eventsBin.toggle) {\n    eventsBin.toggle();\n  }\n};\n\nlet controlBarFocusIn = (e) => {\n  if (e.target && controlBar.contains(e.target)) {\n    if (!controlBar.classList.contains('control-bar-show')) {\n      showControlBar();\n    }\n  }\n};\n\nlet controlBarFocusOut = (e) => {\n  if ((e.relatedTarget && !controlBar.contains(e.relatedTarget)) || !e.relatedTarget) {\n    hideControlBar();\n  }\n};\n\nlet cancelAudio = () => {\n  // optional track cancel event\n  if (eventsBin.cancel) {\n    try {\n      eventsBin.cancel();\n    }\n    catch (e) {}\n  }\n  // move focus to appropriate place, because the cancel button is about to disappear\n  if (controlBar.contains(this)) {\n    controlBar.focus();\n  }\n  if (controlBubble.contains(this)) {\n    controlBubble.focus();\n  }\n  cancel();\n};\n\nlet attachEvents = () => {\n  controlBubble.querySelector('button.play-pause-resume').addEventListener('click', (e) => {\n    if (!ritmEnabled) {return false;}\n\n    e.stopPropagation();\n    let currentContentGroup = e.target.closest(`.${groupClassName}`);\n    contentGroupManager(currentContentGroup);\n  });\n  controlBubble.querySelector('button.cancel-audio').addEventListener('click', cancelAudio);\n\n  controlBar.querySelector('button').addEventListener('click', cancelAudio);\n  controlBar.querySelector('input.switch-input').addEventListener('change', toggleReadItToMe);\n  controlBar.addEventListener('focusin', controlBarFocusIn);\n  controlBar.addEventListener('focusout', controlBarFocusOut);\n\n  let groups = document.querySelectorAll(`.${groupClassName}`);\n  groups.forEach((elem) => {\n    elem.addEventListener('mouseenter', groupSelectorEnter);\n    elem.addEventListener('click', groupSelectorEnter);\n    elem.addEventListener('mouseleave', groupSelectorLeave);\n    elem.addEventListener('focusin', groupFocusInListener);\n    elem.addEventListener('focusout', groupFocusOutListener);\n  });\n};\n\nlet contentGroupManager = (currentContentGroup) => {\n  if (!currentContentGroup.classList.contains('read-it-to-me-play') && !currentContentGroup.classList.contains('read-it-to-me-pause')) {\n    contentQueue.push(currentContentGroup);\n    if (document.querySelectorAll('.read-it-to-me-play').length > 0 || document.querySelectorAll('.read-it-to-me-pause').length > 0) {\n      cancel();\n    }\n    else {\n      play();\n    }\n    currentContentGroup.classList.toggle('read-it-to-me-play');\n  }\n  else if (currentContentGroup.classList.contains('read-it-to-me-play')) {\n    pause();\n    currentContentGroup.classList.toggle('read-it-to-me-play');\n    currentContentGroup.classList.toggle('read-it-to-me-pause');\n  }\n  else if (currentContentGroup.classList.contains('read-it-to-me-pause')) {\n    resume();\n    currentContentGroup.classList.toggle('read-it-to-me-play');\n    currentContentGroup.classList.toggle('read-it-to-me-pause');\n  }\n};\n\nlet clearContentGroup = (contentGroup) => {\n  contentGroup.classList.remove('read-it-to-me-play');\n  contentGroup.classList.remove('read-it-to-me-pause');\n};\n\nlet showCancelButton = () => {\n  controlBar.classList.add('show-ritm-cancel');\n};\n\nlet hideCancelButton = () => {\n  controlBar.classList.remove('show-ritm-cancel');\n};\n\nlet showControlBar = () => {\n  controlBar.classList.add('control-bar-show');\n};\n\nlet hideControlBar = () => {\n  controlBar.classList.remove('control-bar-show');\n};\n\nlet getPlainTextWithPsuedoSemantics = (textAncestor) => {\n  // In a copy of the node list, pepper in (dramatically misuse, hehe) some punctuation for the purpose of adding meaningful pauses and 'emphasis' during text readout.\n  let clonedTextAncestor = textAncestor.cloneNode(true);\n  clonedTextAncestor.querySelectorAll('p, li, abbr, strong, em, h1, h2, h3, h4, h5, h6').forEach((elem) => {\n    let tag = elem.tagName.toUpperCase();\n    if (tag === 'P') {\n      elem.appendChild(document.createTextNode('. '));\n    }\n    else if (tag === \"ABBR\") {\n      let elemText = elem.textContent;\n      let arr = elemText.split('');\n      elem.textContent = arr.join('.');\n    }\n    else if (tag === 'STRONG' || tag === 'EM') {\n      elem.insertBefore(document.createTextNode(', '), elem.firstChild);\n      elem.appendChild(document.createTextNode(', '));\n    }\n    else if (tag === 'LI') {\n      elem.appendChild(document.createTextNode(', '));\n    }\n    else if (tag === 'H1' || tag === 'H2' || tag === 'H3' || tag === 'H4' || tag === 'H5' || tag === 'H6') {\n      elem.appendChild(document.createTextNode(', '));\n    }\n  });\n\n  // return the modified text\n  return clonedTextAncestor.textContent;\n};\n\nlet utteranceEnd = () => {\n  if (contentQueue.length > 0) {\n    clearContentGroup(contentQueue[0]);\n    hideControlBar();\n    hideCancelButton();\n    contentQueue.shift();\n  }\n  if (contentQueue.length > 0) {\n    play();\n  }\n};\n\nlet play = () => {\n  // setup the new utterance\n  let enhancedText = getPlainTextWithPsuedoSemantics(contentQueue[0].querySelector('.read-this-to-me'));\n  synth.play({text: enhancedText}, utteranceEnd);\n  showCancelButton();\n  showControlBar();\n\n  // optional track play event\n  if (eventsBin.play) {\n    eventsBin.play();\n  }\n};\n\nlet pause = () => {\n  synth.pause();\n\n  // optional track pause event\n  if (eventsBin.pause) {\n    eventsBin.pause();\n  }\n};\n\nlet resume = () => {\n  synth.resume();\n};\n\nlet cancel = () => {\n  hideCancelButton();\n  synth.cancel();\n};\n\nexport function init(selectors) {\n  // If there's nothing to read, don't initialize\n  if (!((selectors && document.querySelectorAll(selectors).length > 0) || document.querySelectorAll(`.${groupClassName}`).length > 0)) {\n    return;\n  }\n\n  initSynthesis(undefined, (error, synthesis) => {\n    if (!error && synthesis) {\n      synth = synthesis;\n\n      // if custom selectors were passed in, give the associated elements the default group class\n      if (selectors && document.querySelectorAll(selectors).length > 0) {\n        document.querySelectorAll(selectors).forEach((elem) => {\n          elem.classList.add(groupClassName);\n        });\n      }\n      // make all groups tabable\n      document.querySelectorAll(`.${groupClassName}`).forEach((elem) => {\n        makeElemTabable(elem);\n      });\n    }\n    else {\n      // strip out classes that would apply ReadItToMe visuals\n      document.querySelectorAll(`.${groupClassName}`).forEach((elem) => {\n        elem.classList.remove(groupClassName, focusClassName);\n      });\n    }\n  });\n}\n\nexport function isEnabled () {\n  return ritmEnabled;\n}\n\nexport function currentUtteranceIdentifier() {\n  if (contentQueue[0] && contentQueue[0].dataset.ritmOptionalTrackingIdentifier && contentQueue[0].dataset.ritmOptionalTrackingIdentifier !== \"\") {\n    return contentQueue[0].dataset.ritmOptionalTrackingIdentifier;\n  }\n  return false;\n}\n\nexport function eventTracking(obj) {\n  if (obj) {\n    if (obj.play && typeof obj.play === 'function') {\n      eventsBin.play = obj.play;\n    }\n    if (obj.pause && typeof obj.pause === 'function') {\n      eventsBin.pause = obj.pause;\n    }\n    if (obj.cancel && typeof obj.cancel === 'function') {\n      eventsBin.cancel = obj.cancel;\n    }\n    if (obj.toggle && typeof obj.toggle === 'function') {\n      eventsBin.toggle = obj.toggle;\n    }\n  }\n}","export function initSynthesis(synth, callback) {\n  let voices = [], failedToLoadVoices = false;\n\n  if (!synth && typeof speechSynthesis !== 'undefined') {\n    synth = speechSynthesis;\n  }\n\n  if (!synth) {\n    callback(new Error('Speech Synthesis is unavailable.'));\n    return;\n  }\n\n  let play = (config, callback = () => {}) => {\n    const u = new SpeechSynthesisUtterance(config.text);\n    u.lang = 'en-US';\n    u.rate = .8;\n    //if voices is populated and the 'Samantha' voice is present on the browser/device, load her up, otherwise don't set a voice so the default is allowed to do it's thing.\n    if (voices.length > 0) {\n      for (let i = 0; i < voices.length; i++) {\n        if (voices[i].lang.indexOf('en') === 0) {\n          if (voices[i].name === 'Samantha') {\n            u.voice = voices[i];\n            break;\n          }\n        }\n      }\n    }\n\n    u.onend = () => callback(null, config);\n\n    u.onerror = event => {\n      setTimeout(() => callback(event.error || new Error('Unknown speech synthesis error'), config), 100);\n    };\n\n    // speak the new utterance\n    synth.speak(u);\n  };\n\n  let pause = () => {\n    synth.pause();\n  };\n\n  let resume = () => {\n    synth.resume();\n  };\n\n  let cancel = () => {\n    synth.cancel();\n  };\n\n  const result = {play, pause, resume, cancel};\n\n  //populate voices [chrome currently will only do this in the context of the onvoiceschanged event]\n  voices = synth.getVoices();\n  if (voices.length === 0) {\n    if (synth.onvoiceschanged !== undefined) {\n      synth.onvoiceschanged = function () {\n        voices = synth.getVoices();\n        callback(null, result);\n      };\n    } else {\n      failedToLoadVoices = true;\n    }\n  }\n\n  // without this initial cancel, Chrome will pretty consistently fail to play the very first utterance (then works on every other utterance)\n  synth.cancel();\n\n  if (!voices.length && failedToLoadVoices) {\n    callback(new Error('Unable to load voice list'));\n  } else if (voices.length) {\n    callback(null, result);\n  }\n}\n"],"names":["groupClassName","focusClassName","contentQueue","ritmEnabled","eventsBin","play","pause","cancel","toggle","makeElemTabable","elem","hasAttribute","classList","contains","add","setAttribute","init","selectors","document","querySelectorAll","length","synth","callback","voices","failedToLoadVoices","speechSynthesis","result","config","u","SpeechSynthesisUtterance","text","lang","rate","i","indexOf","name","voice","onend","onerror","event","setTimeout","error","Error","speak","resume","getVoices","undefined","onvoiceschanged","initSynthesis","synthesis","forEach","remove","isEnabled","currentUtteranceIdentifier","dataset","ritmOptionalTrackingIdentifier","eventTracking","obj"],"mappings":"AAMA,IAAMA,EAAiB,8BACjBC,EAAiB,UACnBC,EAAe,GAGfC,GAAc,EACdC,EAAY,CACdC,KAAM,KACNC,MAAO,KACPC,OAAQ,KACRC,OAAQ,MAcNC,EAAkB,SAACC,GAChBA,EAAKC,aAAa,YAIhBD,EAAKE,UAAUC,SAAS,+BAC3BH,EAAKE,UAAUE,IAAI,8BAJrBJ,EAAKK,aAAa,WAAY,MAkY3B,SAASC,EAAKC,IAEZA,GAAaC,SAASC,iBAAiBF,GAAWG,OAAS,GAAMF,SAASC,4BAAqBnB,IAAkBoB,OAAS,ICpa5H,SAAuBC,EAAOC,OAC/BC,EAAS,GAAIC,GAAqB,KAEjCH,GAAoC,oBAApBI,kBACnBJ,EAAQI,iBAGLJ,OA2CCK,EAAS,CAACrB,KAtCL,SAACsB,OAAQL,yDAAW,aACvBM,EAAI,IAAIC,yBAAyBF,EAAOG,SAC9CF,EAAEG,KAAO,QACTH,EAAEI,KAAO,GAELT,EAAOH,OAAS,MACb,IAAIa,EAAI,EAAGA,EAAIV,EAAOH,OAAQa,OACI,IAAjCV,EAAOU,GAAGF,KAAKG,QAAQ,OACF,aAAnBX,EAAOU,GAAGE,KAAqB,CACjCP,EAAEQ,MAAQb,EAAOU,SAOzBL,EAAES,MAAQ,kBAAMf,EAAS,KAAMK,IAE/BC,EAAEU,QAAU,SAAAC,GACVC,WAAW,kBAAMlB,EAASiB,EAAME,OAAS,IAAIC,MAAM,kCAAmCf,IAAS,MAIjGN,EAAMsB,MAAMf,IAeQtB,MAZV,WACVe,EAAMf,SAWqBsC,OARhB,WACXvB,EAAMuB,UAO6BrC,OAJxB,WACXc,EAAMd,WAOc,KADtBgB,EAASF,EAAMwB,aACJzB,cACqB0B,IAA1BzB,EAAM0B,gBACR1B,EAAM0B,gBAAkB,WACtBxB,EAASF,EAAMwB,YACfvB,EAAS,KAAMI,IAGjBF,GAAqB,GAKzBH,EAAMd,UAEDgB,EAAOH,QAAUI,EACpBF,EAAS,IAAIoB,MAAM,8BACVnB,EAAOH,QAChBE,EAAS,KAAMI,QA/DfJ,EAAS,IAAIoB,MAAM,qCDgarBM,MAAcF,EAAW,SAACL,EAAOQ,IAC1BR,GAASQ,GAIRhC,GAAaC,SAASC,iBAAiBF,GAAWG,OAAS,GAC7DF,SAASC,iBAAiBF,GAAWiC,QAAQ,SAACxC,GAC5CA,EAAKE,UAAUE,IAAId,KAIvBkB,SAASC,4BAAqBnB,IAAkBkD,QAAQ,SAACxC,GACvDD,EAAgBC,MAKlBQ,SAASC,4BAAqBnB,IAAkBkD,QAAQ,SAACxC,GACvDA,EAAKE,UAAUuC,OAAOnD,EAAgBC,OAM9C,SAAgBmD,WACPjD,EAGT,SAAgBkD,aACVnD,EAAa,KAAMA,EAAa,GAAGoD,QAAQC,gCAA6F,KAA3DrD,EAAa,GAAGoD,QAAQC,iCAChGrD,EAAa,GAAGoD,QAAQC,+BAK5B,SAASC,EAAcC,GACxBA,IACEA,EAAIpD,MAA4B,mBAAboD,EAAIpD,OACzBD,EAAUC,KAAOoD,EAAIpD,MAEnBoD,EAAInD,OAA8B,mBAAdmD,EAAInD,QAC1BF,EAAUE,MAAQmD,EAAInD,OAEpBmD,EAAIlD,QAAgC,mBAAfkD,EAAIlD,SAC3BH,EAAUG,OAASkD,EAAIlD,QAErBkD,EAAIjD,QAAgC,mBAAfiD,EAAIjD,SAC3BJ,EAAUI,OAASiD,EAAIjD"}